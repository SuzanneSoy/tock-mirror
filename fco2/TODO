To-do list for FCO
------------------

Add an option for whether to compile out overflow/bounds checks.

Add a -o option to control where the output goes (stdout by default for now).

Have a final pass that checks all the mangling has been done -- i.e. function
calls have been removed, and so on.

Multidimensional array literals won't work.

Array indexing needs to be checked against the bounds (which'll do away with a
lot of the "_sizes unused" warnings).

We could have genSpec generate {} around specs if it's not immediately inside
another spec (which'd require some extra boolean arguments to find out).

Type checks need adding to the parser.

The show instance for types should produce occam-looking types.

We should have a "current type context" in the parser, so that VAL BYTE b IS 4:
works correctly.

Tock would be a good name for this (Translator from occam to C from Kent).

There should be a wrapper for SetErr that takes a Meta and an error message.
Ops and array references should use it.

If the assembler-analysis approach to working out process sizes works, then we
can put the sizes in variables in a separate object file and only
generate/compile that after we've done the main one.

Before code generation, have a pass that resolves all the DATA TYPE .. IS
directives to their real types.

genTopLevel should look at what interface the PROC is actually expecting, like
occ21 does.

Output item expressions should be pulled up to variables.

Replicator loops should be special-cased for when base == 0 to generate the
sort of loop a C programmer would normally write.

IF could detect, like CASE, whether it's got a TRUE branch.

IF could generate a simple if ... else ... without the gotos and label when
there's no replication or specs.

genParRep uses a C99 dynamic array for a dynamic PAR count, which may turn out
to be a bad idea for very large counts (since I assume it'll allocate off the
stack). We should probably do a malloc if it's not determinable at compile
time.

The indentation parser is way too simplistic.

ParseState should be called something more sensible, since most of it has
nothing to do with parsing.

Types needs cleaning up and Haddocking.

Types should provide versions of the functions that work in a state monad.
If we can make them work in the parser monad (by providing an instance of
MonadState for it?), that'd be even better.

If we have constant folding, we're three-quarters of the way towards having an
occam *interpreter*.

Pass to turn subscripted expressions into subscripted variables.

Think about simplifying the subscript types -- just have a single data type
that takes several expressions.

